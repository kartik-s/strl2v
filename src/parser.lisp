;;;; Parse sexprs into AST

(in-package :strl2v)

(defun parse (top-level-decls)
  (let ((modules (mapcar #'parse-module top-level-decls)))
    (make-program :modules modules)))

(defun parse-module (module)
  (unless (listp module)
    (error "expected a top-level module declaration, but got ~a instead" module))
  (unless (eql (first module) 'module)
    (error "a top-level module declaration should begin with the keyword 'module', not ~a" (first module)))
  (unless (atom (second module))
    (error "expected a module name, got ~a instead" (second module)))
  (let ((name (second module))
	(inputs (parse-module-inputs (third module)))
	(outputs (parse-module-outputs (fourth module)))
	(body (parse-stmt (fifth module))))
    (make-module-def :name name :inputs inputs :outputs outputs :body body)))

(defun parse-module-inputs (inputs)
  (unless (listp inputs)
    (error "expected a list of module inputs, but got ~a instead" inputs))
  (unless (eql (first inputs) 'inputs)
    (error "the list of module inputs should begin with the keyword 'inputs', not ~a" (first inputs)))
  (mapcar #'parse-signal (rest inputs)))

(defun parse-module-outputs (outputs)
  (unless (listp outputs)
    (error "expected a list of module outputs, but got ~a instead" outputs))
  (unless (eql (first outputs) 'outputs)
    (error "the list of module outputs should begin with the keyword 'outputs', not ~a" (first outputs)))
  (mapcar #'parse-signal (rest outputs)))

(defun parse-signal (sig)
  (unless (atom sig)
    (error "expected a signal name, got ~a" sig))
  (make-signal-name :name sig))

(defun parse-stmt (stmt)
  (cond ((atom stmt)
	 (case stmt
	   (nothing (make-nothing-stmt))
	   (pause (make-pause-stmt))
	   (t (error "expected a statement, but got ~a instead" stmt))))
	((listp stmt)
	 (case (first stmt)
	   (seq (make-seq-stmt :statements (mapcar #'parse-stmt (rest stmt))))
	   (par (make-par-stmt :branches (mapcar #'parse-stmt (rest stmt))))
	   (loop (make-loop-stmt :body (parse-stmt (second stmt))))
	   (loop-each (parse-loop-each-stmt stmt))
	   (let-sig (parse-sig-decl-stmt stmt))
	   (emit (parse-emit-stmt stmt))
	   (present (parse-present-stmt stmt))
	   (suspend-when (parse-suspend-stmt stmt))
	   (trap (parse-trap-stmt stmt))
	   (exit (parse-exit-stmt stmt))
	   (await (parse-await-stmt stmt))
	   (t (error "expected a statement, got ~a instead" stmt))))))

(defun parse-loop-each-stmt (stmt)
  (when (null (second stmt))
    (error "expected a signal after loop-each, but got nothing"))
  (make-loop-each-stmt :signal (parse-signal (second stmt))
		       :body (parse-stmt (third stmt))))

(defun parse-sig-decl-stmt (stmt)
  (when (null (second stmt))
    (error "expected one or more signals after let-sig, but got nothing"))
  (make-sig-decl-stmt :signals (if (listp (second stmt))
				   (mapcar #'parse-signal (second stmt))
				   (list (parse-signal (second stmt))))
		      :body (third stmt)))


(defun parse-emit-stmt (stmt)
  (when (null (rest stmt))
    (error "expected one or more signals after emit, but got nothing"))
  (make-emit-stmt :signals (mapcar #'parse-signal (rest stmt))))

(defun parse-present-stmt (stmt)
  (when (null (second stmt))
    (error "expected a signal after present but got nothing"))
  (make-present-stmt :signal (parse-signal (second stmt))
		     :then-body (parse-stmt (third stmt))))

(defun parse-suspend-stmt (stmt)
  (when (null (second stmt))
    (error "expected a signal after suspend-when but got nothing"))
  (make-suspend-stmt :signal (parse-signal (second stmt))
		     :body (parse-stmt (third stmt))))

(defun parse-trap-stmt (stmt)
  (when (null (second stmt))
    (error "expected a label after trap but got nothing"))
  (make-trap-stmt :label (parse-label (second stmt))
		  :body (parse-stmt (third stmt))))

(defun parse-exit-stmt (stmt)
  (when (null (second stmt))
    (error "expected a label after exit but got nothing"))
  (make-exit-stmt :label (parse-label (second stmt))))

(defun parse-await-stmt (stmt)
  (when (null (second stmt))
    (error "expected a signal after await but got nothing"))
  (make-await-stmt :signal (parse-signal (second stmt))))
